import glob
import os

import SimpleITK as sitk
import math
import numpy as np
import tensorflow as tf
import tensorflow_addons as tfa

IMG_WIDTH = 256
IMG_HEIGHT = 256

"""
cast all : function that make casting to float 32

input: img         : size-[width, height]
       mask_lun    : size-[width, height]
       mask(covid) : size-[width, height]


output: img         : size-[width, height]
        mask_lun    : size-[width, height]
        mask(covid) : size-[width, height]

"""


@tf.function
def cast_all(img, gt_bin, gt_mult):
    img = tf.cast(img, tf.float32)
    gt_bin = tf.cast(gt_bin, tf.float32)
    gt_mult = tf.cast(gt_mult, tf.float32)

    return img, gt_bin, gt_mult


"""
crop_aug : function that make crop and then resize to the original size 
                    when the crop is generated by tf function

input: img         : size-[width, height]
       mask_lun    : size-[width, height]
       mask(covid) : size-[width, height]

output: img         : size-[width, height]
        mask_lun    : size-[width, height]
        mask(covid) : size-[width, height]
"""

def combine_img_gt(img, gt_l, gt_c):
    return tf.concat([img, gt_l, gt_c], axis=-1)


def unpack(combined):
    img = combined[..., 0]
    gt_l = combined[..., 1]
    gt_c = combined[..., 2]
    return img[..., tf.newaxis], gt_l[..., tf.newaxis], gt_c[..., tf.newaxis]


@tf.function
def crop_aug(img, gt_l, gt_c):

    # create the crop
    combined = combine_img_gt(img, gt_l, gt_c)
    crop_combined = tf.image.random_crop(combined, size=[IMG_WIDTH, IMG_HEIGHT,3])

    img, gt_l, gt_c=unpack(crop_combined)


    return img, gt_l, gt_c




"""
truncate_rotation : function that make rotation to the image 
                    when the rotation angle is generated by truncated gaussian

input: img         : size-[width, height]
       mask_lun    : size-[width, height]
       mask(covid) : size-[width, height]

output: img         : size-[width, height]
        mask_lun    : size-[width, height]
        mask(covid) : size-[width, height]
"""

@tf.function
def truncate_rotation_zeros(img, gt_l, gt_c):
    combined = combine_img_gt(img, gt_l, gt_c)

    # randomize the angle and convert to radian
    angle = tf.random.truncated_normal((1,), mean=0, stddev=15) * math.pi / 180
    # tf.print(angle)
    rotate_combined = tfa.image.rotate(combined, angles=angle, interpolation='NEAREST')

    img, gt_l, gt_c = unpack(rotate_combined)


    return img, gt_l, gt_c




"""
Applies affine augmentation on every slice
input: img         : size-[width, height]
       mask_lun    : size-[width, height]
       mask(covid) : size-[width, height]

input: img         : size-[width, height]
       mask_lun    : size-[width, height]
       mask(covid) : size-[width, height]
"""

@tf.function
def affine_aug_no_rotate_zeros(img, gt_bin, gt_mult):


    combined = combine_img_gt(img, gt_bin, gt_mult)
    params = tf.random.uniform((4,), -0.1, 0.1)

    aug_combine = tfa.image.transform(combined,
                                      [params[0] + 1, params[1], 0, params[2], params[3] + 1, 0, 0, 0])

    img, gt_bin, gt_mult = unpack(aug_combine)


    return img, gt_bin, gt_mult


@tf.function
def concat_gt(img, gt_bin, gt_mult):
    img = img
    gt_bin = gt_bin
    gt_mult = gt_mult

    mask_final = tf.concat((gt_bin, gt_mult), axis=-1)

    return img, mask_final


def binarize_ground_truth(gt):
    gt_binary = gt.copy()
    gt_binary[gt_binary > 0] = 1
    return gt_binary


def resize_func(array, data_size, **kwargs):

    array = tf.image.resize(array[...,tf.newaxis], tuple(data_size), **kwargs).numpy()

    return array


def clip(imgs,config):
    v_min = config["Clip_Value_Low"]
    v_max = config["Clip_Value_High"]
    if not (v_min is None):
        imgs[imgs<v_min]=v_min
    if not (v_min is None):
        imgs[imgs>v_max]=v_max
    return imgs


def normalize(imgs, config):
    v_min = config["Clip_Value_Low"]
    v_max = config["Clip_Value_High"]
    if (v_min is None) or (v_max is None): # instance normalization
        v_min=imgs.min()
        v_max=imgs.max()
    imgs=(imgs-v_min)/(v_max-v_min)
    return imgs


def get_bbox(img):
    rows = np.any(img, axis=1)
    cols = np.any(img, axis=0)
    rmin, rmax = np.where(rows)[0][[0, -1]]
    cmin, cmax = np.where(cols)[0][[0, -1]]

    return rmin, rmax, cmin, cmax

def filter_bg(imgs, gt):
    cpy = imgs.copy()
    fg_mask = np.logical_not(np.all(cpy<=0.2,axis=(0,3)))
    rmin, rmax, cmin, cmax = get_bbox(fg_mask)
    return imgs[:,rmin:rmax,cmin:cmax,:], gt[:,rmin:rmax,cmin:cmax]


"""
load_data_folder : function that get the address to the folder files and load all the files there  

input: folder_name (str): folder address
       dtype (str) : the format name
       image_size (list) : size-[width, height]

output: images : size-[num_images ,width, height]

"""
def load_data_folder(folder_name,config, dtype='nii', **kwargs):
    image_list=[]
    if folder_name is None:
        return None
    path = os.path.join(config["data_path"],folder_name)
    for filename in sorted(glob.glob(path + '*.' + dtype)):
        sitk_tr = sitk.ReadImage(filename)
        sitk_arr = sitk.GetArrayFromImage(sitk_tr)
        sitk_arr = resize_func(sitk_arr, config["Image_Size"], **kwargs)
        image_list.append(sitk_arr)
        if config['quiet'] is False:
            print(filename + ' loaded. size: ' + str(sitk_arr.shape))
    images = np.concatenate(tuple(image_list), axis=0).astype(float)
    return images


def load_folders(config, folders_key):
    ct_images=[]
    lung_gts=[]
    covid_gts=[]
    for ct_folder, lung_folder, covid_folder in zip(*config[folders_key]):

        ct_img = load_data_folder(ct_folder,config, dtype='nii', method= "bilinear")
        lung_gt = load_data_folder(lung_folder,config, dtype='nii', method="nearest")
        covid_gt = load_data_folder(covid_folder,config, dtype='nii', method="nearest")
        if lung_gt is None:
            lung_gt = np.empty_like(ct_img)
            lung_gt[:] = np.NaN

        if covid_gt is None:
            covid_gt = np.empty_like(ct_img)
            covid_gt[:] = np.NaN


        ct_img = clip(ct_img,config)
        ct_img = normalize(ct_img,config)
        ct_images.append(ct_img)
        lung_gts.append(lung_gt)
        covid_gts.append(covid_gt)

    all_ct = np.concatenate(tuple(ct_images), axis=0)
    all_lungs_gt = np.concatenate(tuple(lung_gts), axis=0)
    all_covid_gt = np.concatenate(tuple(covid_gts), axis=0)
    return all_ct, all_lungs_gt, all_covid_gt

def prepare_data(dataset, config, is_train=False):
    dataset=dataset.map(cast_all)

    if is_train and config["Enable_Augmetation"]:

        dataset = dataset.map(crop_aug)
        dataset = dataset.map(affine_aug_no_rotate_zeros)
        dataset = dataset.map(truncate_rotation_zeros)
    dataset=dataset.map(concat_gt)
    if  is_train and config["Enable_Shuffle"]:
        dataset = dataset.shuffle(config["N_Shuffle"]).repeat(config["N_Repeat"])
    dataset = dataset.batch(config["batch_size"])
    return dataset


# @tf.function
def data_loader_train_test(config, train_flag=True):
    data = {}
    if train_flag:
        train_images, train_gt_lungs, train_gt_covid = load_folders(config, "train_folders")

    test_images, test_gt_lungs, test_gt_covid = load_folders(config, "test_folders")


    if config['quiet'] is False:
        if train_flag:
            print(f"train images shape: {train_images.shape}, GT shape: {train_gt_lungs.shape}")
        print(f"test images shape: {test_images.shape}, GT shape: {test_gt_lungs.shape}")

    #training
    if train_flag:
        train_dataset = tf.data.Dataset.from_tensor_slices((train_images,train_gt_lungs, train_gt_covid))
        train_dataset = prepare_data(train_dataset, config, is_train=True)
        data["train"] = train_dataset

    test_dataset = tf.data.Dataset.from_tensor_slices((test_images, test_gt_lungs, test_gt_covid))
    test_dataset = prepare_data(test_dataset, config)
    data["test"] = test_dataset
    return data



if __name__ == '__main__':
    x=2